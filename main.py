import os
import shutil
import subprocess
from pathlib import Path

import numpy as np
from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.responses import FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from PIL import Image

app = FastAPI()

# --- Configuration ---
UPLOAD_DIR = Path("uploads")
OUTPUT_DIR = Path("output")
# IMPORTANT: Please update this path to your Blender executable.
# Example for Windows: "C:\Program Files\Blender Foundation\Blender 4.1\blender.exe"
# Example for macOS: "/Applications/Blender.app/Contents/MacOS/Blender"
# Example for Linux: "blender" (if in PATH) or "/usr/bin/blender"
BLENDER_EXECUTABLE = r"D:\ProgramFiles\blender\blender-launcher.exe" 

# --- Setup Directories ---
for dir_path in [UPLOAD_DIR, OUTPUT_DIR]:
    dir_path.mkdir(exist_ok=True)

app.mount("/output", StaticFiles(directory=OUTPUT_DIR), name="output")

# --- Helper Functions ---

def image_to_obj(image_path: Path, obj_path: Path, threshold=128):
    """Converts the dark parts of an image to a 3D mesh, centers it, and saves it as an OBJ file."""
    try:
        img = Image.open(image_path).convert('L')  # Convert to grayscale
        pixels = np.array(img)
        height, width = pixels.shape

        raw_verts = []
        faces = []
        vert_map = {}

        def get_vert_idx(coord):
            if coord not in vert_map:
                vert_map[coord] = len(raw_verts)
                raw_verts.append(coord)
            return vert_map[coord] + 1 # OBJ indices are 1-based

        # 1. Generate vertices and faces for dark pixels
        for y_idx in range(height):
            for x_idx in range(width):
                if pixels[y_idx, x_idx] < threshold:
                    x, y, z = float(x_idx), float(height - 1 - y_idx), 0.0
                    p = [
                        (x, y, z), (x + 1, y, z), (x + 1, y + 1, z), (x, y + 1, z),
                        (x, y, z + 1), (x + 1, y, z + 1), (x + 1, y + 1, z + 1), (x, y + 1, z + 1)
                    ]
                    v = [get_vert_idx(coord) for coord in p]

                    # Create the 6 faces using vertex indices
                    faces.append(f"f {v[0]} {v[1]} {v[2]} {v[3]}")
                    faces.append(f"f {v[4]} {v[7]} {v[6]} {v[5]}")
                    faces.append(f"f {v[0]} {v[4]} {v[5]} {v[1]}")
                    faces.append(f"f {v[1]} {v[5]} {v[6]} {v[2]}")
                    faces.append(f"f {v[2]} {v[6]} {v[7]} {v[3]}")
                    faces.append(f"f {v[3]} {v[7]} {v[4]} {v[0]}")

        if not raw_verts:
            raise ValueError("No dark pixels found in the image to create a mesh.")

        # 2. Center the vertices
        verts_array = np.array(raw_verts, dtype=np.float32)
        min_coords = verts_array.min(axis=0)
        max_coords = verts_array.max(axis=0)
        center = (min_coords + max_coords) / 2.0
        centered_verts_array = verts_array - center

        # 3. Format vertices for OBJ file
        verts_str = [f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}" for v in centered_verts_array]

        # 4. Write to OBJ file
        with open(obj_path, 'w') as f:
            f.write("# Generated by Image-to-Mesh\n")
            f.write("# Centered Model\n")
            f.write("\n".join(verts_str))
            f.write("\n\n")
            f.write("\n".join(faces))

    except Exception as e:
        print(f"Error in image_to_obj: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to process image: {e}")


def convert_obj_to_fbx(obj_path: Path, fbx_path: Path):
    """Converts an OBJ file to FBX using Blender."""
    script_path = Path("blender_export.py").resolve()
    obj_abs_path = obj_path.resolve()
    fbx_abs_path = fbx_path.resolve()

    command = [
        BLENDER_EXECUTABLE,
        "--background",
        "--python",
        str(script_path),
        "--",
        str(obj_abs_path),
        str(fbx_abs_path)
    ]
    
    print(f"Running Blender command: {' '.join(command)}")

    try:
        process = subprocess.run(command, check=True, capture_output=True, text=True, encoding='utf-8')
        print("Blender stdout:", process.stdout)
        if process.stderr:
            print("Blender stderr:", process.stderr)
    except FileNotFoundError:
        error_msg = f"Blender executable not found at '{BLENDER_EXECUTABLE}'. Please update the BLENDER_EXECUTABLE path in main.py."
        print(error_msg)
        raise HTTPException(status_code=500, detail=error_msg)
    except subprocess.CalledProcessError as e:
        error_msg = f"Blender conversion failed. Return code: {e.returncode}\nStderr: {e.stderr}\nStdout: {e.stdout}"
        print(error_msg)
        raise HTTPException(status_code=500, detail=error_msg)
    except Exception as e:
        error_msg = f"An unexpected error occurred while running Blender: {e}"
        print(error_msg)
        raise HTTPException(status_code=500, detail=error_msg)

# --- API Endpoints ---

@app.get("/")
async def root():
    return FileResponse('templates/index.html')

@app.post("/upload/")
async def upload_file(file: UploadFile = File(...)):
    try:
        # Sanitize filename
        filename = Path(file.filename).name
        base_filename = Path(filename).stem
        
        # Define paths
        image_path = UPLOAD_DIR / filename
        obj_path = OUTPUT_DIR / f"{base_filename}.obj"
        fbx_path = OUTPUT_DIR / f"{base_filename}.fbx"

        # Save the uploaded file
        with open(image_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        # --- Core Logic ---
        # 1. Convert image to OBJ
        print(f"Converting {image_path} to {obj_path}...")
        image_to_obj(image_path, obj_path)
        print("OBJ creation successful.")

        # 2. Convert OBJ to FBX
        print(f"Converting {obj_path} to {fbx_path}...")
        convert_obj_to_fbx(obj_path, fbx_path)
        print("FBX conversion successful.")

        # Clean up uploaded file
        os.remove(image_path)

        # Return links to the generated files
        return JSONResponse({
            "obj_url": f"/output/{obj_path.name}",
            "fbx_url": f"/output/{fbx_path.name}"
        })

    except HTTPException as e:
        # Re-raise the exception to be caught by FastAPI's handler
        return JSONResponse({"error": e.detail}, status_code=e.status_code)
    except Exception as e:
        print(f"An unexpected error occurred in upload_file: {e}")
        return JSONResponse({"error": f"An unexpected error occurred: {e}"}, status_code=500)
    finally:
        # Ensure the file object is closed
        if file and not file.file.closed:
            file.file.close()


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
